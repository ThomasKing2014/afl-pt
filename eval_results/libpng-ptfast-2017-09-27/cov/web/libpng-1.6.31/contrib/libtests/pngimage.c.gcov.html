<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - trace.lcov_info_final - libpng-1.6.31/contrib/libtests/pngimage.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">libpng-1.6.31/contrib/libtests</a> - pngimage.c<span style="font-size: 80%;"> (source / <a href="pngimage.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">trace.lcov_info_final</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">552</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-09-28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">35</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* pngimage.c</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * Copyright (c) 2015,2016 John Cunningham Bowler
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Last changed in libpng 1.6.24 [August 4, 2016]
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * This code is released under the libpng license.
<span class="lineNum">       8 </span>            :  * For conditions of distribution and use, see the disclaimer
<span class="lineNum">       9 </span>            :  * and license in png.h
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * Test the png_read_png and png_write_png interfaces.  Given a PNG file load it
<span class="lineNum">      12 </span>            :  * using png_read_png and then write with png_write_png.  Test all possible
<span class="lineNum">      13 </span>            :  * transforms.
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : #include &lt;stdarg.h&gt;
<span class="lineNum">      16 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #if defined(HAVE_CONFIG_H) &amp;&amp; !defined(PNG_NO_CONFIG_H)
<span class="lineNum">      23 </span>            : #  include &lt;config.h&gt;
<span class="lineNum">      24 </span>            : #endif
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : /* Define the following to use this test against your installed libpng, rather
<span class="lineNum">      27 </span>            :  * than the one being built here:
<span class="lineNum">      28 </span>            :  */
<span class="lineNum">      29 </span>            : #ifdef PNG_FREESTANDING_TESTS
<span class="lineNum">      30 </span>            : #  include &lt;png.h&gt;
<span class="lineNum">      31 </span>            : #else
<span class="lineNum">      32 </span>            : #  include &quot;../../png.h&quot;
<span class="lineNum">      33 </span>            : #endif
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #ifndef PNG_SETJMP_SUPPORTED
<span class="lineNum">      36 </span>            : #  include &lt;setjmp.h&gt; /* because png.h did *not* include this */
<span class="lineNum">      37 </span>            : #endif
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /* 1.6.1 added support for the configure test harness, which uses 77 to indicate
<span class="lineNum">      40 </span>            :  * a skipped test, in earlier versions we need to succeed on a skipped test, so:
<span class="lineNum">      41 </span>            :  */
<span class="lineNum">      42 </span>            : #if PNG_LIBPNG_VER &gt;= 10601 &amp;&amp; defined(HAVE_CONFIG_H)
<span class="lineNum">      43 </span>            : #  define SKIP 77
<span class="lineNum">      44 </span>            : #else
<span class="lineNum">      45 </span>            : #  define SKIP 0
<span class="lineNum">      46 </span>            : #endif
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : #if PNG_LIBPNG_VER &lt; 10700
<span class="lineNum">      49 </span>            :    /* READ_PNG and WRITE_PNG were not defined, so: */
<span class="lineNum">      50 </span>            : #  ifdef PNG_INFO_IMAGE_SUPPORTED
<span class="lineNum">      51 </span>            : #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
<span class="lineNum">      52 </span>            : #        define PNG_READ_PNG_SUPPORTED
<span class="lineNum">      53 </span>            : #     endif /* SEQUENTIAL_READ */
<span class="lineNum">      54 </span>            : #     ifdef PNG_WRITE_SUPPORTED
<span class="lineNum">      55 </span>            : #        define PNG_WRITE_PNG_SUPPORTED
<span class="lineNum">      56 </span>            : #     endif /* WRITE */
<span class="lineNum">      57 </span>            : #  endif /* INFO_IMAGE */
<span class="lineNum">      58 </span>            : #endif /* pre 1.7.0 */
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : #ifdef PNG_READ_PNG_SUPPORTED
<span class="lineNum">      61 </span>            : /* If a transform is valid on both read and write this implies that if the
<span class="lineNum">      62 </span>            :  * transform is applied to read it must also be applied on write to produce
<span class="lineNum">      63 </span>            :  * meaningful data.  This is because these transforms when performed on read
<span class="lineNum">      64 </span>            :  * produce data with a memory format that does not correspond to a PNG format.
<span class="lineNum">      65 </span>            :  *
<span class="lineNum">      66 </span>            :  * Most of these transforms are invertible; after applying the transform on
<span class="lineNum">      67 </span>            :  * write the result is the original PNG data that would have would have been
<span class="lineNum">      68 </span>            :  * read if no transform were applied.
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  * The exception is _SHIFT, which destroys the low order bits marked as not
<span class="lineNum">      71 </span>            :  * significant in a PNG with the sBIT chunk.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * The following table lists, for each transform, the conditions under which it
<span class="lineNum">      74 </span>            :  * is expected to do anything.  Conditions are defined as follows:
<span class="lineNum">      75 </span>            :  *
<span class="lineNum">      76 </span>            :  * 1) Color mask bits required - simply a mask to AND with color_type; one of
<span class="lineNum">      77 </span>            :  *    these must be present for the transform to fire, except that 0 means
<span class="lineNum">      78 </span>            :  *    'always'.
<span class="lineNum">      79 </span>            :  * 2) Color mask bits which must be absent - another mask - none of these must
<span class="lineNum">      80 </span>            :  *    be present.
<span class="lineNum">      81 </span>            :  * 3) Bit depths - a mask of component bit depths for the transform to fire.
<span class="lineNum">      82 </span>            :  * 4) 'read' - the transform works in png_read_png.
<span class="lineNum">      83 </span>            :  * 5) 'write' - the transform works in png_write_png.
<span class="lineNum">      84 </span>            :  * 6) PNG_INFO_chunk; a mask of the chunks that must be present for the
<span class="lineNum">      85 </span>            :  *    transform to fire.  All must be present - the requirement is that
<span class="lineNum">      86 </span>            :  *    png_get_valid() &amp; mask == mask, so if mask is 0 there is no requirement.
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * The condition refers to the original image state - if multiple transforms are
<span class="lineNum">      89 </span>            :  * used together it is possible to cause a transform that wouldn't fire on the
<span class="lineNum">      90 </span>            :  * original image to fire.
<span class="lineNum">      91 </span>            :  */
<span class="lineNum">      92 </span>            : static struct transform_info
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span>            :    const char *name;
<span class="lineNum">      95 </span>            :    int         transform;
<span class="lineNum">      96 </span>            :    png_uint_32 valid_chunks;
<span class="lineNum">      97 </span>            : #     define CHUNK_NONE 0
<span class="lineNum">      98 </span>            : #     define CHUNK_sBIT PNG_INFO_sBIT
<span class="lineNum">      99 </span>            : #     define CHUNK_tRNS PNG_INFO_tRNS
<span class="lineNum">     100 </span>            :    png_byte    color_mask_required;
<span class="lineNum">     101 </span>            :    png_byte    color_mask_absent;
<span class="lineNum">     102 </span>            : #     define COLOR_MASK_X   0
<span class="lineNum">     103 </span>            : #     define COLOR_MASK_P   PNG_COLOR_MASK_PALETTE
<span class="lineNum">     104 </span>            : #     define COLOR_MASK_C   PNG_COLOR_MASK_COLOR
<span class="lineNum">     105 </span>            : #     define COLOR_MASK_A   PNG_COLOR_MASK_ALPHA
<span class="lineNum">     106 </span>            : #     define COLOR_MASK_ALL (PALETTE+COLOR+ALPHA)  /* absent = gray, no alpha */
<span class="lineNum">     107 </span>            :    png_byte    bit_depths;
<span class="lineNum">     108 </span>            : #     define BD_ALL  (1 + 2 + 4 + 8 + 16)
<span class="lineNum">     109 </span>            : #     define BD_PAL  (1 + 2 + 4 + 8)
<span class="lineNum">     110 </span>            : #     define BD_LOW  (1 + 2 + 4)
<span class="lineNum">     111 </span>            : #     define BD_16   16
<span class="lineNum">     112 </span>            : #     define BD_TRUE (8+16) /* i.e. true-color depths */
<span class="lineNum">     113 </span>            :    png_byte    when;
<span class="lineNum">     114 </span>            : #     define TRANSFORM_R  1
<span class="lineNum">     115 </span>            : #     define TRANSFORM_W  2
<span class="lineNum">     116 </span>            : #     define TRANSFORM_RW 3
<span class="lineNum">     117 </span>            :    png_byte    tested; /* the transform was tested somewhere */
<span class="lineNum">     118 </span>            : } transform_info[] =
<span class="lineNum">     119 </span>            : {
<span class="lineNum">     120 </span>            :    /* List ALL the PNG_TRANSFORM_ macros here.  Check for support using the READ
<span class="lineNum">     121 </span>            :     * macros; even if the transform is supported on write it cannot be tested
<span class="lineNum">     122 </span>            :     * without the read support.
<span class="lineNum">     123 </span>            :     */
<span class="lineNum">     124 </span>            : #  define T(name,chunk,cm_required,cm_absent,bd,when)\
<span class="lineNum">     125 </span>            :    {  #name, PNG_TRANSFORM_ ## name, CHUNK_ ## chunk,\
<span class="lineNum">     126 </span>            :       COLOR_MASK_ ## cm_required, COLOR_MASK_ ## cm_absent, BD_ ## bd,\
<span class="lineNum">     127 </span>            :       TRANSFORM_ ## when, 0/*!tested*/ }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
<span class="lineNum">     130 </span>            :    T(STRIP_16,            NONE, X,   X,   16,  R),
<span class="lineNum">     131 </span>            :       /* drops the bottom 8 bits when bit depth is 16 */
<span class="lineNum">     132 </span>            : #endif
<span class="lineNum">     133 </span>            : #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
<span class="lineNum">     134 </span>            :    T(STRIP_ALPHA,         NONE, A,   X,  ALL,  R),
<span class="lineNum">     135 </span>            :       /* removes the alpha channel if present */
<span class="lineNum">     136 </span>            : #endif
<span class="lineNum">     137 </span>            : #ifdef PNG_WRITE_PACK_SUPPORTED
<span class="lineNum">     138 </span>            : #  define TRANSFORM_RW_PACK TRANSFORM_RW
<span class="lineNum">     139 </span>            : #else
<span class="lineNum">     140 </span>            : #  define TRANSFORM_RW_PACK TRANSFORM_R
<span class="lineNum">     141 </span>            : #endif
<span class="lineNum">     142 </span>            : #ifdef PNG_READ_PACK_SUPPORTED
<span class="lineNum">     143 </span>            :    T(PACKING,             NONE, X,   X,  LOW, RW_PACK),
<span class="lineNum">     144 </span>            :       /* unpacks low-bit-depth components into 1 byte per component on read,
<span class="lineNum">     145 </span>            :        * reverses this on write.
<span class="lineNum">     146 </span>            :        */
<span class="lineNum">     147 </span>            : #endif
<span class="lineNum">     148 </span>            : #ifdef PNG_WRITE_PACKSWAP_SUPPORTED
<span class="lineNum">     149 </span>            : #  define TRANSFORM_RW_PACKSWAP TRANSFORM_RW
<span class="lineNum">     150 </span>            : #else
<span class="lineNum">     151 </span>            : #  define TRANSFORM_RW_PACKSWAP TRANSFORM_R
<span class="lineNum">     152 </span>            : #endif
<span class="lineNum">     153 </span>            : #ifdef PNG_READ_PACKSWAP_SUPPORTED
<span class="lineNum">     154 </span>            :    T(PACKSWAP,            NONE, X,   X,  LOW, RW_PACKSWAP),
<span class="lineNum">     155 </span>            :       /* reverses the order of low-bit-depth components packed into a byte */
<span class="lineNum">     156 </span>            : #endif
<span class="lineNum">     157 </span>            : #ifdef PNG_READ_EXPAND_SUPPORTED
<span class="lineNum">     158 </span>            :    T(EXPAND,              NONE, P,   X,  ALL,  R),
<span class="lineNum">     159 </span>            :       /* expands PLTE PNG files to RGB (no tRNS) or RGBA (tRNS) *
<span class="lineNum">     160 </span>            :        * Note that the 'EXPAND' transform does lots of different things: */
<span class="lineNum">     161 </span>            :    T(EXPAND,              NONE, X,   C,  ALL,  R),
<span class="lineNum">     162 </span>            :       /* expands grayscale PNG files to RGB, or RGBA */
<span class="lineNum">     163 </span>            :    T(EXPAND,              tRNS, X,   A,  ALL,  R),
<span class="lineNum">     164 </span>            :       /* expands the tRNS chunk in files without alpha */
<span class="lineNum">     165 </span>            : #endif
<span class="lineNum">     166 </span>            : #ifdef PNG_WRITE_INVERT_SUPPORTED
<span class="lineNum">     167 </span>            : #  define TRANSFORM_RW_INVERT TRANSFORM_RW
<span class="lineNum">     168 </span>            : #else
<span class="lineNum">     169 </span>            : #  define TRANSFORM_RW_INVERT TRANSFORM_R
<span class="lineNum">     170 </span>            : #endif
<span class="lineNum">     171 </span>            : #ifdef PNG_READ_INVERT_SUPPORTED
<span class="lineNum">     172 </span>            :    T(INVERT_MONO,         NONE, X,   C,  ALL, RW_INVERT),
<span class="lineNum">     173 </span>            :       /* converts gray-scale components to 1..0 from 0..1 */
<span class="lineNum">     174 </span>            : #endif
<span class="lineNum">     175 </span>            : #ifdef PNG_WRITE_SHIFT_SUPPORTED
<span class="lineNum">     176 </span>            : #  define TRANSFORM_RW_SHIFT TRANSFORM_RW
<span class="lineNum">     177 </span>            : #else
<span class="lineNum">     178 </span>            : #  define TRANSFORM_RW_SHIFT TRANSFORM_R
<span class="lineNum">     179 </span>            : #endif
<span class="lineNum">     180 </span>            : #ifdef PNG_READ_SHIFT_SUPPORTED
<span class="lineNum">     181 </span>            :    T(SHIFT,               sBIT, X,   X,  ALL, RW_SHIFT),
<span class="lineNum">     182 </span>            :       /* reduces component values to the original range based on the sBIT chunk,
<span class="lineNum">     183 </span>            :        * this is only partially reversible - the low bits are lost and cannot be
<span class="lineNum">     184 </span>            :        * recovered on write.  In fact write code replicates the bits to generate
<span class="lineNum">     185 </span>            :        * new low-order bits.
<span class="lineNum">     186 </span>            :        */
<span class="lineNum">     187 </span>            : #endif
<span class="lineNum">     188 </span>            : #ifdef PNG_WRITE_BGR_SUPPORTED
<span class="lineNum">     189 </span>            : #  define TRANSFORM_RW_BGR TRANSFORM_RW
<span class="lineNum">     190 </span>            : #else
<span class="lineNum">     191 </span>            : #  define TRANSFORM_RW_BGR TRANSFORM_R
<span class="lineNum">     192 </span>            : #endif
<span class="lineNum">     193 </span>            : #ifdef PNG_READ_BGR_SUPPORTED
<span class="lineNum">     194 </span>            :    T(BGR,                 NONE, C,   P, TRUE, RW_BGR),
<span class="lineNum">     195 </span>            :       /* reverses the rgb component values of true-color pixels */
<span class="lineNum">     196 </span>            : #endif
<span class="lineNum">     197 </span>            : #ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
<span class="lineNum">     198 </span>            : #  define TRANSFORM_RW_SWAP_ALPHA TRANSFORM_RW
<span class="lineNum">     199 </span>            : #else
<span class="lineNum">     200 </span>            : #  define TRANSFORM_RW_SWAP_ALPHA TRANSFORM_R
<span class="lineNum">     201 </span>            : #endif
<span class="lineNum">     202 </span>            : #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
<span class="lineNum">     203 </span>            :    T(SWAP_ALPHA,          NONE, A,   X, TRUE, RW_SWAP_ALPHA),
<span class="lineNum">     204 </span>            :       /* swaps the alpha channel of RGBA or GA pixels to the front - ARGB or
<span class="lineNum">     205 </span>            :        * AG, on write reverses the process.
<span class="lineNum">     206 </span>            :        */
<span class="lineNum">     207 </span>            : #endif
<span class="lineNum">     208 </span>            : #ifdef PNG_WRITE_SWAP_SUPPORTED
<span class="lineNum">     209 </span>            : #  define TRANSFORM_RW_SWAP TRANSFORM_RW
<span class="lineNum">     210 </span>            : #else
<span class="lineNum">     211 </span>            : #  define TRANSFORM_RW_SWAP TRANSFORM_R
<span class="lineNum">     212 </span>            : #endif
<span class="lineNum">     213 </span>            : #ifdef PNG_READ_SWAP_SUPPORTED
<span class="lineNum">     214 </span>            :    T(SWAP_ENDIAN,         NONE, X,   P,   16, RW_SWAP),
<span class="lineNum">     215 </span>            :       /* byte-swaps 16-bit component values */
<span class="lineNum">     216 </span>            : #endif
<span class="lineNum">     217 </span>            : #ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
<span class="lineNum">     218 </span>            : #  define TRANSFORM_RW_INVERT_ALPHA TRANSFORM_RW
<span class="lineNum">     219 </span>            : #else
<span class="lineNum">     220 </span>            : #  define TRANSFORM_RW_INVERT_ALPHA TRANSFORM_R
<span class="lineNum">     221 </span>            : #endif
<span class="lineNum">     222 </span>            : #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
<span class="lineNum">     223 </span>            :    T(INVERT_ALPHA,        NONE, A,   X, TRUE, RW_INVERT_ALPHA),
<span class="lineNum">     224 </span>            :       /* converts an alpha channel from 0..1 to 1..0 */
<span class="lineNum">     225 </span>            : #endif
<span class="lineNum">     226 </span>            : #ifdef PNG_WRITE_FILLER_SUPPORTED
<span class="lineNum">     227 </span>            :    T(STRIP_FILLER_BEFORE, NONE, A,   P, TRUE,  W), /* 'A' for a filler! */
<span class="lineNum">     228 </span>            :       /* on write skips a leading filler channel; testing requires data with a
<span class="lineNum">     229 </span>            :        * filler channel so this is produced from RGBA or GA images by removing
<span class="lineNum">     230 </span>            :        * the 'alpha' flag from the color type in place.
<span class="lineNum">     231 </span>            :        */
<span class="lineNum">     232 </span>            :    T(STRIP_FILLER_AFTER,  NONE, A,   P, TRUE,  W),
<span class="lineNum">     233 </span>            :       /* on write strips a trailing filler channel */
<span class="lineNum">     234 </span>            : #endif
<span class="lineNum">     235 </span>            : #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
<span class="lineNum">     236 </span>            :    T(GRAY_TO_RGB,         NONE, X,   C,  ALL,  R),
<span class="lineNum">     237 </span>            :       /* expands grayscale images to RGB, also causes the palette part of
<span class="lineNum">     238 </span>            :        * 'EXPAND' to happen.  Low bit depth grayscale images are expanded to
<span class="lineNum">     239 </span>            :        * 8-bits per component and no attempt is made to convert the image to a
<span class="lineNum">     240 </span>            :        * palette image.  While this transform is partially reversible
<span class="lineNum">     241 </span>            :        * png_write_png does not currently support this.
<span class="lineNum">     242 </span>            :        */
<span class="lineNum">     243 </span>            :    T(GRAY_TO_RGB,         NONE, P,   X,  ALL,  R),
<span class="lineNum">     244 </span>            :       /* The 'palette' side effect mentioned above; a bit bogus but this is the
<span class="lineNum">     245 </span>            :        * way the libpng code works.
<span class="lineNum">     246 </span>            :        */
<span class="lineNum">     247 </span>            : #endif
<span class="lineNum">     248 </span>            : #ifdef PNG_READ_EXPAND_16_SUPPORTED
<span class="lineNum">     249 </span>            :    T(EXPAND_16,           NONE, X,   X,  PAL,  R),
<span class="lineNum">     250 </span>            :       /* expands images to 16-bits per component, as a side effect expands
<span class="lineNum">     251 </span>            :        * palette images to RGB and expands the tRNS chunk if present, so it can
<span class="lineNum">     252 </span>            :        * modify 16-bit per component images as well:
<span class="lineNum">     253 </span>            :        */
<span class="lineNum">     254 </span>            :    T(EXPAND_16,           tRNS, X,   A,   16,  R),
<span class="lineNum">     255 </span>            :       /* side effect of EXPAND_16 - expands the tRNS chunk in an RGB or G 16-bit
<span class="lineNum">     256 </span>            :        * image.
<span class="lineNum">     257 </span>            :        */
<span class="lineNum">     258 </span>            : #endif
<span class="lineNum">     259 </span>            : #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
<span class="lineNum">     260 </span>            :    T(SCALE_16,            NONE, X,   X,   16,  R),
<span class="lineNum">     261 </span>            :       /* scales 16-bit components to 8-bits. */
<span class="lineNum">     262 </span>            : #endif
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :    { NULL /*name*/, 0, 0, 0, 0, 0, 0, 0/*!tested*/ }
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : #undef T
<span class="lineNum">     267 </span>            : };
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : #define ARRAY_SIZE(a) ((sizeof a)/(sizeof a[0]))
<span class="lineNum">     270 </span>            : #define TTABLE_SIZE ARRAY_SIZE(transform_info)
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : /* Some combinations of options that should be reversible are not; these cases
<span class="lineNum">     273 </span>            :  * are bugs.
<span class="lineNum">     274 </span>            :  */
<span class="lineNum">     275 </span>            : static int known_bad_combos[][2] =
<span class="lineNum">     276 </span>            : {
<span class="lineNum">     277 </span>            :    /* problem, antidote */
<span class="lineNum">     278 </span>            :    { PNG_TRANSFORM_SHIFT | PNG_TRANSFORM_INVERT_ALPHA, 0/*antidote*/ }
<span class="lineNum">     279 </span>            : };
<a name="280"><span class="lineNum">     280 </span>            : </a>
<span class="lineNum">     281 </span>            : static int
<span class="lineNum">     282 </span><span class="lineNoCov">          0 : is_combo(int transforms)</span>
<span class="lineNum">     283 </span>            : {
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :    return transforms &amp; (transforms-1); /* non-zero if more than one set bit */</span>
<span class="lineNum">     285 </span>            : }
<a name="286"><span class="lineNum">     286 </span>            : </a>
<span class="lineNum">     287 </span>            : static int
<span class="lineNum">     288 </span><span class="lineNoCov">          0 : first_transform(int transforms)</span>
<span class="lineNum">     289 </span>            : {
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :    return transforms &amp; -transforms; /* lowest set bit */</span>
<span class="lineNum">     291 </span>            : }
<a name="292"><span class="lineNum">     292 </span>            : </a>
<span class="lineNum">     293 </span>            : static int
<span class="lineNum">     294 </span><span class="lineNoCov">          0 : is_bad_combo(int transforms)</span>
<span class="lineNum">     295 </span>            : {
<span class="lineNum">     296 </span>            :    unsigned int i;
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :    for (i=0; i&lt;ARRAY_SIZE(known_bad_combos); ++i)</span>
<span class="lineNum">     299 </span>            :    {
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       int combo = known_bad_combos[i][0];</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       if ((combo &amp; transforms) == combo &amp;&amp;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :          (transforms &amp; known_bad_combos[i][1]) == 0)</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :          return 1;</span>
<span class="lineNum">     305 </span>            :    }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :    return 0; /* combo is ok */</span>
<span class="lineNum">     308 </span>            : }
<a name="309"><span class="lineNum">     309 </span>            : </a>
<span class="lineNum">     310 </span>            : static const char *
<span class="lineNum">     311 </span><span class="lineNoCov">          0 : transform_name(int t)</span>
<span class="lineNum">     312 </span>            :    /* The name, if 't' has multiple bits set the name of the lowest set bit is
<span class="lineNum">     313 </span>            :     * returned.
<span class="lineNum">     314 </span>            :     */
<span class="lineNum">     315 </span>            : {
<span class="lineNum">     316 </span>            :    unsigned int i;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :    t &amp;= -t; /* first set bit */</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :    for (i=0; i&lt;TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)</span>
<span class="lineNum">     321 </span>            :    {
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :       if ((transform_info[i].transform &amp; t) != 0)</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :          return transform_info[i].name;</span>
<span class="lineNum">     324 </span>            :    }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :    return &quot;invalid transform&quot;;</span>
<span class="lineNum">     327 </span>            : }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /* Variables calculated by validate_T below and used to record all the supported
<span class="lineNum">     330 </span>            :  * transforms.  Need (unsigned int) here because of the places where these
<span class="lineNum">     331 </span>            :  * values are used (unsigned compares in the 'exhaustive' iterator.)
<span class="lineNum">     332 </span>            :  */
<span class="lineNum">     333 </span>            : static unsigned int read_transforms, write_transforms, rw_transforms;
<a name="334"><span class="lineNum">     334 </span>            : </a>
<span class="lineNum">     335 </span>            : static void
<span class="lineNum">     336 </span><span class="lineNoCov">          0 : validate_T(void)</span>
<span class="lineNum">     337 </span>            :    /* Validate the above table - this just builds the above values */
<span class="lineNum">     338 </span>            : {
<span class="lineNum">     339 </span>            :    unsigned int i;
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :    for (i=0; i&lt;TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)</span>
<span class="lineNum">     342 </span>            :    {
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       if (transform_info[i].when &amp; TRANSFORM_R)</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :          read_transforms |= transform_info[i].transform;</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       if (transform_info[i].when &amp; TRANSFORM_W)</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :          write_transforms |= transform_info[i].transform;</span>
<span class="lineNum">     348 </span>            :    }
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :    /* Reversible transforms are those which are supported on both read and
<span class="lineNum">     351 </span>            :     * write.
<span class="lineNum">     352 </span>            :     */
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :    rw_transforms = read_transforms &amp; write_transforms;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : /* FILE DATA HANDLING
<span class="lineNum">     357 </span>            :  *    The original file is cached in memory.  During write the output file is
<span class="lineNum">     358 </span>            :  *    written to memory.
<span class="lineNum">     359 </span>            :  *
<span class="lineNum">     360 </span>            :  *    In both cases the file data is held in a linked list of buffers - not all
<span class="lineNum">     361 </span>            :  *    of these are in use at any time.
<span class="lineNum">     362 </span>            :  */
<span class="lineNum">     363 </span>            : #define NEW(type) ((type *)malloc(sizeof (type)))
<span class="lineNum">     364 </span>            : #define DELETE(ptr) (free(ptr))
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : struct buffer_list
<span class="lineNum">     367 </span>            : {
<span class="lineNum">     368 </span>            :    struct buffer_list *next;         /* next buffer in list */
<span class="lineNum">     369 </span>            :    png_byte            buffer[1024]; /* the actual buffer */
<span class="lineNum">     370 </span>            : };
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : struct buffer
<span class="lineNum">     373 </span>            : {
<span class="lineNum">     374 </span>            :    struct buffer_list  *last;       /* last buffer in use */
<span class="lineNum">     375 </span>            :    size_t               end_count;  /* bytes in the last buffer */
<span class="lineNum">     376 </span>            :    struct buffer_list  *current;    /* current buffer being read */
<span class="lineNum">     377 </span>            :    size_t               read_count; /* count of bytes read from current */
<span class="lineNum">     378 </span>            :    struct buffer_list   first;      /* the very first buffer */
<span class="lineNum">     379 </span>            : };
<a name="380"><span class="lineNum">     380 </span>            : </a>
<span class="lineNum">     381 </span>            : static void
<span class="lineNum">     382 </span><span class="lineNoCov">          0 : buffer_init(struct buffer *buffer)</span>
<span class="lineNum">     383 </span>            :    /* Call this only once for a given buffer */
<span class="lineNum">     384 </span>            : {
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :    buffer-&gt;first.next = NULL;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :    buffer-&gt;last = NULL;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :    buffer-&gt;current = NULL;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 : }</span>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<span class="lineNum">     390 </span>            : static void
<span class="lineNum">     391 </span><span class="lineNoCov">          0 : buffer_destroy_list(struct buffer_list *list)</span>
<span class="lineNum">     392 </span>            : {
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :    if (list != NULL)</span>
<span class="lineNum">     394 </span>            :    {
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :       struct buffer_list *next = list-&gt;next;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       DELETE(list);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :       buffer_destroy_list(next);</span>
<span class="lineNum">     398 </span>            :    }
<span class="lineNum">     399 </span><span class="lineNoCov">          0 : }</span>
<a name="400"><span class="lineNum">     400 </span>            : </a>
<span class="lineNum">     401 </span>            : static void
<span class="lineNum">     402 </span><span class="lineNoCov">          0 : buffer_destroy(struct buffer *buffer)</span>
<span class="lineNum">     403 </span>            : {
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :    struct buffer_list *list = buffer-&gt;first.next;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :    buffer_init(buffer);</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :    buffer_destroy_list(list);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     408 </span>            : 
<a name="409"><span class="lineNum">     409 </span>            : #ifdef PNG_WRITE_PNG_SUPPORTED</a>
<span class="lineNum">     410 </span>            : static void
<span class="lineNum">     411 </span><span class="lineNoCov">          0 : buffer_start_write(struct buffer *buffer)</span>
<span class="lineNum">     412 </span>            : {
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :    buffer-&gt;last = &amp;buffer-&gt;first;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :    buffer-&gt;end_count = 0;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :    buffer-&gt;current = NULL;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     417 </span>            : #endif
<a name="418"><span class="lineNum">     418 </span>            : </a>
<span class="lineNum">     419 </span>            : static void
<span class="lineNum">     420 </span><span class="lineNoCov">          0 : buffer_start_read(struct buffer *buffer)</span>
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :    buffer-&gt;current = &amp;buffer-&gt;first;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :    buffer-&gt;read_count = 0;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : #ifdef ENOMEM /* required by POSIX 1003.1 */
<span class="lineNum">     427 </span>            : #  define MEMORY ENOMEM
<span class="lineNum">     428 </span>            : #else
<span class="lineNum">     429 </span>            : #  define MEMORY ERANGE /* required by ANSI-C */
<a name="430"><span class="lineNum">     430 </span>            : #endif</a>
<span class="lineNum">     431 </span>            : static struct buffer *
<span class="lineNum">     432 </span><span class="lineNoCov">          0 : get_buffer(png_structp pp)</span>
<span class="lineNum">     433 </span>            :    /* Used from libpng callbacks to get the current buffer */
<span class="lineNum">     434 </span>            : {
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :    return (struct buffer*)png_get_io_ptr(pp);</span>
<span class="lineNum">     436 </span>            : }
<a name="437"><span class="lineNum">     437 </span>            : </a>
<span class="lineNum">     438 </span>            : static struct buffer_list *
<span class="lineNum">     439 </span><span class="lineNoCov">          0 : buffer_extend(struct buffer_list *current)</span>
<span class="lineNum">     440 </span>            : {
<span class="lineNum">     441 </span>            :    struct buffer_list *add;
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :    assert(current-&gt;next == NULL);</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :    add = NEW(struct buffer_list);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :    if (add == NULL)</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :    add-&gt;next = NULL;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :    current-&gt;next = add;</span>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :    return add;</span>
<span class="lineNum">     453 </span>            : }
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : /* Load a buffer from a file; does the equivalent of buffer_start_write.  On a
<span class="lineNum">     456 </span>            :  * read error returns an errno value, else returns 0.
<a name="457"><span class="lineNum">     457 </span>            :  */</a>
<span class="lineNum">     458 </span>            : static int
<span class="lineNum">     459 </span><span class="lineNoCov">          0 : buffer_from_file(struct buffer *buffer, FILE *fp)</span>
<span class="lineNum">     460 </span>            : {
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :    struct buffer_list *last = &amp;buffer-&gt;first;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :    size_t count = 0;</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :    for (;;)
<span class="lineNum">     465 </span>            :    {
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       size_t r = fread(last-&gt;buffer+count, 1/*size*/,</span>
<span class="lineNum">     467 </span>            :          (sizeof last-&gt;buffer)-count, fp);
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :       if (r &gt; 0)</span>
<span class="lineNum">     470 </span>            :       {
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :          count += r;</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :          if (count &gt;= sizeof last-&gt;buffer)</span>
<span class="lineNum">     474 </span>            :          {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :             assert(count == sizeof last-&gt;buffer);</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :             count = 0;</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :             if (last-&gt;next == NULL)</span>
<span class="lineNum">     479 </span>            :             {
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                last = buffer_extend(last);</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                if (last == NULL)</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                   return MEMORY;</span>
<span class="lineNum">     483 </span>            :             }
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :             else
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                last = last-&gt;next;</span>
<span class="lineNum">     487 </span>            :          }
<span class="lineNum">     488 </span>            :       }
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :       else /* fread failed - probably end of file */
<span class="lineNum">     491 </span>            :       {
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :          if (feof(fp))</span>
<span class="lineNum">     493 </span>            :          {
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :             buffer-&gt;last = last;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :             buffer-&gt;end_count = count;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :             return 0; /* no error */</span>
<span class="lineNum">     497 </span>            :          }
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :          /* Some kind of funky error; errno should be non-zero */
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :          return errno == 0 ? ERANGE : errno;</span>
<span class="lineNum">     501 </span>            :       }
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :    }</span>
<span class="lineNum">     503 </span>            : }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : /* This structure is used to control the test of a single file. */
<span class="lineNum">     506 </span>            : typedef enum
<span class="lineNum">     507 </span>            : {
<span class="lineNum">     508 </span>            :    VERBOSE,        /* switches on all messages */
<span class="lineNum">     509 </span>            :    INFORMATION,
<span class="lineNum">     510 </span>            :    WARNINGS,       /* switches on warnings */
<span class="lineNum">     511 </span>            :    LIBPNG_WARNING,
<span class="lineNum">     512 </span>            :    APP_WARNING,
<span class="lineNum">     513 </span>            :    ERRORS,         /* just errors */
<span class="lineNum">     514 </span>            :    APP_FAIL,       /* continuable error - no need to longjmp */
<span class="lineNum">     515 </span>            :    LIBPNG_ERROR,   /* this and higher cause a longjmp */
<span class="lineNum">     516 </span>            :    LIBPNG_BUG,     /* erroneous behavior in libpng */
<span class="lineNum">     517 </span>            :    APP_ERROR,      /* such as out-of-memory in a callback */
<span class="lineNum">     518 </span>            :    QUIET,          /* no normal messages */
<span class="lineNum">     519 </span>            :    USER_ERROR,     /* such as file-not-found */
<span class="lineNum">     520 </span>            :    INTERNAL_ERROR
<span class="lineNum">     521 </span>            : } error_level;
<span class="lineNum">     522 </span>            : #define LEVEL_MASK      0xf   /* where the level is in 'options' */
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : #define EXHAUSTIVE      0x010 /* Test all combinations of active options */
<span class="lineNum">     525 </span>            : #define STRICT          0x020 /* Fail on warnings as well as errors */
<span class="lineNum">     526 </span>            : #define LOG             0x040 /* Log pass/fail to stdout */
<span class="lineNum">     527 </span>            : #define CONTINUE        0x080 /* Continue on APP_FAIL errors */
<span class="lineNum">     528 </span>            : #define SKIP_BUGS       0x100 /* Skip over known bugs */
<span class="lineNum">     529 </span>            : #define LOG_SKIPPED     0x200 /* Log skipped bugs */
<span class="lineNum">     530 </span>            : #define FIND_BAD_COMBOS 0x400 /* Attempt to deduce bad combos */
<span class="lineNum">     531 </span>            : #define LIST_COMBOS     0x800 /* List combos by name */
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : /* Result masks apply to the result bits in the 'results' field below; these
<span class="lineNum">     534 </span>            :  * bits are simple 1U&lt;&lt;error_level.  A pass requires either nothing worse than
<span class="lineNum">     535 </span>            :  * warnings (--relaxes) or nothing worse than information (--strict)
<span class="lineNum">     536 </span>            :  */
<span class="lineNum">     537 </span>            : #define RESULT_STRICT(r)   (((r) &amp; ~((1U&lt;&lt;WARNINGS)-1)) == 0)
<span class="lineNum">     538 </span>            : #define RESULT_RELAXED(r)  (((r) &amp; ~((1U&lt;&lt;ERRORS)-1)) == 0)
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : struct display
<span class="lineNum">     541 </span>            : {
<span class="lineNum">     542 </span>            :    jmp_buf        error_return;      /* Where to go to on error */
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            :    const char    *filename;          /* The name of the original file */
<span class="lineNum">     545 </span>            :    const char    *operation;         /* Operation being performed */
<span class="lineNum">     546 </span>            :    int            transforms;        /* Transform used in operation */
<span class="lineNum">     547 </span>            :    png_uint_32    options;           /* See display_log below */
<span class="lineNum">     548 </span>            :    png_uint_32    results;           /* A mask of errors seen */
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :    png_structp    original_pp;       /* used on the original read */
<span class="lineNum">     552 </span>            :    png_infop      original_ip;       /* set by the original read */
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :    png_size_t     original_rowbytes; /* of the original rows: */
<span class="lineNum">     555 </span>            :    png_bytepp     original_rows;     /* from the original read */
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            :    /* Original chunks valid */
<span class="lineNum">     558 </span>            :    png_uint_32    chunks;
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :    /* Original IHDR information */
<span class="lineNum">     561 </span>            :    png_uint_32    width;
<span class="lineNum">     562 </span>            :    png_uint_32    height;
<span class="lineNum">     563 </span>            :    int            bit_depth;
<span class="lineNum">     564 </span>            :    int            color_type;
<span class="lineNum">     565 </span>            :    int            interlace_method;
<span class="lineNum">     566 </span>            :    int            compression_method;
<span class="lineNum">     567 </span>            :    int            filter_method;
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :    /* Derived information for the original image. */
<span class="lineNum">     570 </span>            :    int            active_transforms;  /* transforms that do something on read */
<span class="lineNum">     571 </span>            :    int            ignored_transforms; /* transforms that should do nothing */
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :    /* Used on a read, both the original read and when validating a written
<span class="lineNum">     574 </span>            :     * image.
<span class="lineNum">     575 </span>            :     */
<span class="lineNum">     576 </span>            :    png_structp    read_pp;
<span class="lineNum">     577 </span>            :    png_infop      read_ip;
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            : #  ifdef PNG_WRITE_PNG_SUPPORTED
<span class="lineNum">     580 </span>            :       /* Used to write a new image (the original info_ptr is used) */
<span class="lineNum">     581 </span>            :       png_structp   write_pp;
<span class="lineNum">     582 </span>            :       struct buffer written_file;   /* where the file gets written */
<span class="lineNum">     583 </span>            : #  endif
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :    struct buffer  original_file;     /* Data read from the original file */
<span class="lineNum">     586 </span>            : };
<a name="587"><span class="lineNum">     587 </span>            : </a>
<span class="lineNum">     588 </span>            : static void
<span class="lineNum">     589 </span><span class="lineNoCov">          0 : display_init(struct display *dp)</span>
<span class="lineNum">     590 </span>            :    /* Call this only once right at the start to initialize the control
<span class="lineNum">     591 </span>            :     * structure, the (struct buffer) lists are maintained across calls - the
<span class="lineNum">     592 </span>            :     * memory is not freed.
<span class="lineNum">     593 </span>            :     */
<span class="lineNum">     594 </span>            : {
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :    memset(dp, 0, sizeof *dp);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :    dp-&gt;options = WARNINGS; /* default to !verbose, !quiet */</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :    dp-&gt;filename = NULL;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :    dp-&gt;operation = NULL;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :    dp-&gt;original_pp = NULL;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :    dp-&gt;original_ip = NULL;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :    dp-&gt;original_rows = NULL;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :    dp-&gt;read_pp = NULL;</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :    dp-&gt;read_ip = NULL;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :    buffer_init(&amp;dp-&gt;original_file);</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : #  ifdef PNG_WRITE_PNG_SUPPORTED
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :       dp-&gt;write_pp = NULL;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :       buffer_init(&amp;dp-&gt;written_file);</span>
<span class="lineNum">     609 </span>            : #  endif
<span class="lineNum">     610 </span><span class="lineNoCov">          0 : }</span>
<a name="611"><span class="lineNum">     611 </span>            : </a>
<span class="lineNum">     612 </span>            : static void
<span class="lineNum">     613 </span><span class="lineNoCov">          0 : display_clean_read(struct display *dp)</span>
<span class="lineNum">     614 </span>            : {
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :    if (dp-&gt;read_pp != NULL)</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :       png_destroy_read_struct(&amp;dp-&gt;read_pp, &amp;dp-&gt;read_ip, NULL);</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     618 </span>            : 
<a name="619"><span class="lineNum">     619 </span>            : #ifdef PNG_WRITE_PNG_SUPPORTED</a>
<span class="lineNum">     620 </span>            : static void
<span class="lineNum">     621 </span><span class="lineNoCov">          0 : display_clean_write(struct display *dp)</span>
<span class="lineNum">     622 </span>            : {
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :       if (dp-&gt;write_pp != NULL)</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :          png_destroy_write_struct(&amp;dp-&gt;write_pp, NULL);</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     626 </span>            : #endif
<a name="627"><span class="lineNum">     627 </span>            : </a>
<span class="lineNum">     628 </span>            : static void
<span class="lineNum">     629 </span><span class="lineNoCov">          0 : display_clean(struct display *dp)</span>
<span class="lineNum">     630 </span>            : {
<span class="lineNum">     631 </span>            : #  ifdef PNG_WRITE_PNG_SUPPORTED
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :       display_clean_write(dp);</span>
<span class="lineNum">     633 </span>            : #  endif
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :    display_clean_read(dp);</span>
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :    dp-&gt;original_rowbytes = 0;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :    dp-&gt;original_rows = NULL;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :    dp-&gt;chunks = 0;</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :    png_destroy_read_struct(&amp;dp-&gt;original_pp, &amp;dp-&gt;original_ip, NULL);</span>
<span class="lineNum">     641 </span>            :    /* leave the filename for error detection */
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :    dp-&gt;results = 0; /* reset for next time */</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 : }</span>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<span class="lineNum">     645 </span>            : static void
<span class="lineNum">     646 </span><span class="lineNoCov">          0 : display_destroy(struct display *dp)</span>
<span class="lineNum">     647 </span>            : {
<span class="lineNum">     648 </span>            :     /* Release any memory held in the display. */
<span class="lineNum">     649 </span>            : #  ifdef PNG_WRITE_PNG_SUPPORTED
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :       buffer_destroy(&amp;dp-&gt;written_file);</span>
<span class="lineNum">     651 </span>            : #  endif
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :    buffer_destroy(&amp;dp-&gt;original_file);</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 : }</span>
<a name="655"><span class="lineNum">     655 </span>            : </a>
<span class="lineNum">     656 </span>            : static struct display *
<span class="lineNum">     657 </span><span class="lineNoCov">          0 : get_dp(png_structp pp)</span>
<span class="lineNum">     658 </span>            :    /* The display pointer is always stored in the png_struct error pointer */
<span class="lineNum">     659 </span>            : {
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :    struct display *dp = (struct display*)png_get_error_ptr(pp);</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :    if (dp == NULL)</span>
<span class="lineNum">     663 </span>            :    {
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       fprintf(stderr, &quot;pngimage: internal error (no display)\n&quot;);</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       exit(99); /* prevents a crash */</span>
<span class="lineNum">     666 </span>            :    }
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :    return dp;</span>
<span class="lineNum">     669 </span>            : }
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : /* error handling */
<span class="lineNum">     672 </span>            : #ifdef __GNUC__
<span class="lineNum">     673 </span>            : #  define VGATTR __attribute__((__format__ (__printf__,3,4)))
<span class="lineNum">     674 </span>            :    /* Required to quiet GNUC warnings when the compiler sees a stdarg function
<span class="lineNum">     675 </span>            :     * that calls one of the stdio v APIs.
<span class="lineNum">     676 </span>            :     */
<span class="lineNum">     677 </span>            : #else
<span class="lineNum">     678 </span>            : #  define VGATTR
<a name="679"><span class="lineNum">     679 </span>            : #endif</a>
<span class="lineNum">     680 </span>            : static void VGATTR
<span class="lineNum">     681 </span><span class="lineNoCov">          0 : display_log(struct display *dp, error_level level, const char *fmt, ...)</span>
<span class="lineNum">     682 </span>            :    /* 'level' is as above, fmt is a stdio style format string.  This routine
<span class="lineNum">     683 </span>            :     * does not return if level is above LIBPNG_WARNING
<span class="lineNum">     684 </span>            :     */
<span class="lineNum">     685 </span>            : {
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :    dp-&gt;results |= 1U &lt;&lt; level;</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :    if (level &gt; (error_level)(dp-&gt;options &amp; LEVEL_MASK))</span>
<span class="lineNum">     689 </span>            :    {
<span class="lineNum">     690 </span>            :       const char *lp;
<span class="lineNum">     691 </span>            :       va_list ap;
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :       switch (level)</span>
<span class="lineNum">     694 </span>            :       {
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :          case INFORMATION:    lp = &quot;information&quot;; break;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :          case LIBPNG_WARNING: lp = &quot;warning(libpng)&quot;; break;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :          case APP_WARNING:    lp = &quot;warning(pngimage)&quot;; break;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :          case APP_FAIL:       lp = &quot;error(continuable)&quot;; break;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :          case LIBPNG_ERROR:   lp = &quot;error(libpng)&quot;; break;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :          case LIBPNG_BUG:     lp = &quot;bug(libpng)&quot;; break;</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :          case APP_ERROR:      lp = &quot;error(pngimage)&quot;; break;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :          case USER_ERROR:     lp = &quot;error(user)&quot;; break;</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            :          case INTERNAL_ERROR: /* anything unexpected is an internal error: */
<span class="lineNum">     705 </span>            :          case VERBOSE: case WARNINGS: case ERRORS: case QUIET:
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :          default:             lp = &quot;bug(pngimage)&quot;; break;</span>
<span class="lineNum">     707 </span>            :       }
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :       fprintf(stderr, &quot;%s: %s: %s&quot;,</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :          dp-&gt;filename != NULL ? dp-&gt;filename : &quot;&lt;stdin&gt;&quot;, lp, dp-&gt;operation);</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       if (dp-&gt;transforms != 0)</span>
<span class="lineNum">     713 </span>            :       {
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :          int tr = dp-&gt;transforms;</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :          if (is_combo(tr))</span>
<span class="lineNum">     717 </span>            :          {
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :             if (dp-&gt;options &amp; LIST_COMBOS)</span>
<span class="lineNum">     719 </span>            :             {
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :                int trx = tr;</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :                fprintf(stderr, &quot;(&quot;);</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :                if (trx)</span>
<span class="lineNum">     724 </span>            :                {
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :                   int start = 0;</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :                   while (trx)</span>
<span class="lineNum">     728 </span>            :                   {
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :                      int trz = trx &amp; -trx;</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :                      if (start) fprintf(stderr, &quot;+&quot;);</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :                      fprintf(stderr, &quot;%s&quot;, transform_name(trz));</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                      start = 1;</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :                      trx &amp;= ~trz;</span>
<span class="lineNum">     735 </span>            :                   }
<span class="lineNum">     736 </span>            :                }
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :                else
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :                   fprintf(stderr, &quot;-&quot;);</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :                fprintf(stderr, &quot;)&quot;);</span>
<span class="lineNum">     741 </span>            :             }
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :             else
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                fprintf(stderr, &quot;(0x%x)&quot;, tr);</span>
<span class="lineNum">     745 </span>            :          }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :          else
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :             fprintf(stderr, &quot;(%s)&quot;, transform_name(tr));</span>
<span class="lineNum">     749 </span>            :       }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :       fprintf(stderr, &quot;: &quot;);</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       va_start(ap, fmt);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :       vfprintf(stderr, fmt, ap);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       va_end(ap);</span>
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       fputc('\n', stderr);</span>
<span class="lineNum">     758 </span>            :    }
<span class="lineNum">     759 </span>            :    /* else do not output any message */
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :    /* Errors cause this routine to exit to the fail code */
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :    if (level &gt; APP_FAIL || (level &gt; ERRORS &amp;&amp; !(dp-&gt;options &amp; CONTINUE)))</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :       longjmp(dp-&gt;error_return, level);</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     765 </span>            : 
<a name="766"><span class="lineNum">     766 </span>            : /* error handler callbacks for libpng */</a>
<span class="lineNum">     767 </span>            : static void PNGCBAPI
<span class="lineNum">     768 </span><span class="lineNoCov">          0 : display_warning(png_structp pp, png_const_charp warning)</span>
<span class="lineNum">     769 </span>            : {
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :    display_log(get_dp(pp), LIBPNG_WARNING, &quot;%s&quot;, warning);</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 : }</span>
<a name="772"><span class="lineNum">     772 </span>            : </a>
<span class="lineNum">     773 </span>            : static void PNGCBAPI
<span class="lineNum">     774 </span><span class="lineNoCov">          0 : display_error(png_structp pp, png_const_charp error)</span>
<span class="lineNum">     775 </span>            : {
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :    struct display *dp = get_dp(pp);</span>
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :    display_log(dp, LIBPNG_ERROR, &quot;%s&quot;, error);</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 : }</span>
<a name="780"><span class="lineNum">     780 </span>            : </a>
<span class="lineNum">     781 </span>            : static void
<span class="lineNum">     782 </span><span class="lineNoCov">          0 : display_cache_file(struct display *dp, const char *filename)</span>
<span class="lineNum">     783 </span>            :    /* Does the initial cache of the file. */
<span class="lineNum">     784 </span>            : {
<span class="lineNum">     785 </span>            :    FILE *fp;
<span class="lineNum">     786 </span>            :    int ret;
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :    dp-&gt;filename = filename;</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :    if (filename != NULL)</span>
<span class="lineNum">     791 </span>            :    {
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :       fp = fopen(filename, &quot;rb&quot;);</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :       if (fp == NULL)</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :          display_log(dp, USER_ERROR, &quot;open failed: %s&quot;, strerror(errno));</span>
<span class="lineNum">     795 </span>            :    }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :    else
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :       fp = stdin;</span>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :    ret = buffer_from_file(&amp;dp-&gt;original_file, fp);</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :    fclose(fp);</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :    if (ret != 0)</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       display_log(dp, APP_ERROR, &quot;read failed: %s&quot;, strerror(ret));</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 : }</span>
<a name="807"><span class="lineNum">     807 </span>            : </a>
<span class="lineNum">     808 </span>            : static void
<span class="lineNum">     809 </span><span class="lineNoCov">          0 : buffer_read(struct display *dp, struct buffer *bp, png_bytep data,</span>
<span class="lineNum">     810 </span>            :    png_size_t size)
<span class="lineNum">     811 </span>            : {
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :    struct buffer_list *last = bp-&gt;current;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :    size_t read_count = bp-&gt;read_count;</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :    while (size &gt; 0)</span>
<span class="lineNum">     816 </span>            :    {
<span class="lineNum">     817 </span>            :       size_t avail;
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       if (last == NULL ||</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :          (last == bp-&gt;last &amp;&amp; read_count &gt;= bp-&gt;end_count))</span>
<span class="lineNum">     821 </span>            :       {
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :          display_log(dp, USER_ERROR, &quot;file truncated (%lu bytes)&quot;,</span>
<span class="lineNum">     823 </span>            :             (unsigned long)size);
<span class="lineNum">     824 </span>            :          /*NOTREACHED*/
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :          break;</span>
<span class="lineNum">     826 </span>            :       }
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       else if (read_count &gt;= sizeof last-&gt;buffer)</span>
<span class="lineNum">     829 </span>            :       {
<span class="lineNum">     830 </span>            :          /* Move to the next buffer: */
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :          last = last-&gt;next;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :          read_count = 0;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :          bp-&gt;current = last; /* Avoid update outside the loop */</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :          /* And do a sanity check (the EOF case is caught above) */
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :          if (last == NULL)</span>
<span class="lineNum">     837 </span>            :          {
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :             display_log(dp, INTERNAL_ERROR, &quot;damaged buffer list&quot;);</span>
<span class="lineNum">     839 </span>            :             /*NOTREACHED*/
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     841 </span>            :          }
<span class="lineNum">     842 </span>            :       }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :       avail = (sizeof last-&gt;buffer) - read_count;</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :       if (avail &gt; size)</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :          avail = size;</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :       memcpy(data, last-&gt;buffer + read_count, avail);</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :       read_count += avail;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :       size -= avail;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :       data += avail;</span>
<span class="lineNum">     852 </span>            :    }
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :    bp-&gt;read_count = read_count;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 : }</span>
<a name="856"><span class="lineNum">     856 </span>            : </a>
<span class="lineNum">     857 </span>            : static void PNGCBAPI
<span class="lineNum">     858 </span><span class="lineNoCov">          0 : read_function(png_structp pp, png_bytep data, png_size_t size)</span>
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :    buffer_read(get_dp(pp), get_buffer(pp), data, size);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 : }</span>
<a name="862"><span class="lineNum">     862 </span>            : </a>
<span class="lineNum">     863 </span>            : static void
<span class="lineNum">     864 </span><span class="lineNoCov">          0 : read_png(struct display *dp, struct buffer *bp, const char *operation,</span>
<span class="lineNum">     865 </span>            :    int transforms)
<span class="lineNum">     866 </span>            : {
<span class="lineNum">     867 </span>            :    png_structp pp;
<span class="lineNum">     868 </span>            :    png_infop   ip;
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :    /* This cleans out any previous read and sets operation and transforms to
<span class="lineNum">     871 </span>            :     * empty.
<span class="lineNum">     872 </span>            :     */
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :    display_clean_read(dp);</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :    if (operation != NULL) /* else this is a verify and do not overwrite info */</span>
<span class="lineNum">     876 </span>            :    {
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :       dp-&gt;operation = operation;</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       dp-&gt;transforms = transforms;</span>
<span class="lineNum">     879 </span>            :    }
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :    dp-&gt;read_pp = pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, dp,</span>
<span class="lineNum">     882 </span>            :       display_error, display_warning);
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :    if (pp == NULL)</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :       display_log(dp, LIBPNG_ERROR, &quot;failed to create read struct&quot;);</span>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            :    /* The png_read_png API requires us to make the info struct, but it does the
<span class="lineNum">     887 </span>            :     * call to png_read_info.
<span class="lineNum">     888 </span>            :     */
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :    dp-&gt;read_ip = ip = png_create_info_struct(pp);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :    if (ip == NULL)</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :       display_log(dp, LIBPNG_ERROR, &quot;failed to create info struct&quot;);</span>
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span>            : #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
<span class="lineNum">     894 </span>            :       /* Remove the user limits, if any */
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :       png_set_user_limits(pp, 0x7fffffff, 0x7fffffff);</span>
<span class="lineNum">     896 </span>            : #  endif
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            :    /* Set the IO handling */
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :    buffer_start_read(bp);</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :    png_set_read_fn(pp, bp, read_function);</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :    png_read_png(pp, ip, transforms, NULL/*params*/);</span>
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span>            : #if 0 /* crazy debugging */
<span class="lineNum">     905 </span>            :    {
<span class="lineNum">     906 </span>            :       png_bytep pr = png_get_rows(pp, ip)[0];
<span class="lineNum">     907 </span>            :       size_t rb = png_get_rowbytes(pp, ip);
<span class="lineNum">     908 </span>            :       size_t cb;
<span class="lineNum">     909 </span>            :       char c = ' ';
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            :       fprintf(stderr, &quot;%.4x %2d (%3lu bytes):&quot;, transforms, png_get_bit_depth(pp,ip), (unsigned long)rb);
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :       for (cb=0; cb&lt;rb; ++cb)
<span class="lineNum">     914 </span>            :          fputc(c, stderr), fprintf(stderr, &quot;%.2x&quot;, pr[cb]), c='.';
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :       fputc('\n', stderr);
<span class="lineNum">     917 </span>            :    }
<span class="lineNum">     918 </span>            : #endif
<span class="lineNum">     919 </span><span class="lineNoCov">          0 : }</span>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<span class="lineNum">     921 </span>            : static void
<span class="lineNum">     922 </span><span class="lineNoCov">          0 : update_display(struct display *dp)</span>
<span class="lineNum">     923 </span>            :    /* called once after the first read to update all the info, original_pp and
<span class="lineNum">     924 </span>            :     * original_ip must have been filled in.
<span class="lineNum">     925 </span>            :     */
<span class="lineNum">     926 </span>            : {
<span class="lineNum">     927 </span>            :    png_structp pp;
<span class="lineNum">     928 </span>            :    png_infop   ip;
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :    /* Now perform the initial read with a 0 tranform. */
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :    read_png(dp, &amp;dp-&gt;original_file, &quot;original read&quot;, 0/*no transform*/);</span>
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            :    /* Move the result to the 'original' fields */
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :    dp-&gt;original_pp = pp = dp-&gt;read_pp, dp-&gt;read_pp = NULL;</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :    dp-&gt;original_ip = ip = dp-&gt;read_ip, dp-&gt;read_ip = NULL;</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :    dp-&gt;original_rowbytes = png_get_rowbytes(pp, ip);</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :    if (dp-&gt;original_rowbytes == 0)</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :       display_log(dp, LIBPNG_BUG, &quot;png_get_rowbytes returned 0&quot;);</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :    dp-&gt;chunks = png_get_valid(pp, ip, 0xffffffff);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :    if ((dp-&gt;chunks &amp; PNG_INFO_IDAT) == 0) /* set by png_read_png */</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       display_log(dp, LIBPNG_BUG, &quot;png_read_png did not set IDAT flag&quot;);</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :    dp-&gt;original_rows = png_get_rows(pp, ip);</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :    if (dp-&gt;original_rows == NULL)</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :       display_log(dp, LIBPNG_BUG, &quot;png_read_png did not create row buffers&quot;);</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :    if (!png_get_IHDR(pp, ip,</span>
<span class="lineNum">     950 </span>            :       &amp;dp-&gt;width, &amp;dp-&gt;height, &amp;dp-&gt;bit_depth, &amp;dp-&gt;color_type,
<span class="lineNum">     951 </span>            :       &amp;dp-&gt;interlace_method, &amp;dp-&gt;compression_method, &amp;dp-&gt;filter_method))
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       display_log(dp, LIBPNG_BUG, &quot;png_get_IHDR failed&quot;);</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :    /* 'active' transforms are discovered based on the original image format;
<span class="lineNum">     955 </span>            :     * running one active transform can activate others.  At present the code
<span class="lineNum">     956 </span>            :     * does not attempt to determine the closure.
<span class="lineNum">     957 </span>            :     */
<span class="lineNum">     958 </span>            :    {
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :       png_uint_32 chunks = dp-&gt;chunks;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       int active = 0, inactive = 0;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :       int ct = dp-&gt;color_type;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :       int bd = dp-&gt;bit_depth;</span>
<span class="lineNum">     963 </span>            :       unsigned int i;
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :       for (i=0; i&lt;TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)</span>
<span class="lineNum">     966 </span>            :       {
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :          int transform = transform_info[i].transform;</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :          if ((transform_info[i].valid_chunks == 0 ||</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :                (transform_info[i].valid_chunks &amp; chunks) != 0) &amp;&amp;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :             (transform_info[i].color_mask_required &amp; ct) ==</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :                transform_info[i].color_mask_required &amp;&amp;</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :             (transform_info[i].color_mask_absent &amp; ct) == 0 &amp;&amp;</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :             (transform_info[i].bit_depths &amp; bd) != 0 &amp;&amp;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :             (transform_info[i].when &amp; TRANSFORM_R) != 0)</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :             active |= transform;</span>
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :          else if ((transform_info[i].when &amp; TRANSFORM_R) != 0)</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :             inactive |= transform;</span>
<span class="lineNum">     980 </span>            :       }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :       /* Some transforms appear multiple times in the table; the 'active' status
<span class="lineNum">     983 </span>            :        * is the logical OR of these and the inactive status must be adjusted to
<span class="lineNum">     984 </span>            :        * take this into account.
<span class="lineNum">     985 </span>            :        */
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :       inactive &amp;= ~active;</span>
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :       dp-&gt;active_transforms = active;</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :       dp-&gt;ignored_transforms = inactive; /* excluding write-only transforms */</span>
<span class="lineNum">     990 </span>            :    }
<span class="lineNum">     991 </span><span class="lineNoCov">          0 : }</span>
<a name="992"><span class="lineNum">     992 </span>            : </a>
<span class="lineNum">     993 </span>            : static int
<span class="lineNum">     994 </span><span class="lineNoCov">          0 : compare_read(struct display *dp, int applied_transforms)</span>
<span class="lineNum">     995 </span>            : {
<span class="lineNum">     996 </span>            :    /* Compare the png_info from read_ip with original_info */
<span class="lineNum">     997 </span>            :    size_t rowbytes;
<span class="lineNum">     998 </span>            :    png_uint_32 width, height;
<span class="lineNum">     999 </span>            :    int bit_depth, color_type;
<span class="lineNum">    1000 </span>            :    int interlace_method, compression_method, filter_method;
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :    const char *e = NULL;</span>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :    png_get_IHDR(dp-&gt;read_pp, dp-&gt;read_ip, &amp;width, &amp;height, &amp;bit_depth,</span>
<span class="lineNum">    1004 </span>            :       &amp;color_type, &amp;interlace_method, &amp;compression_method, &amp;filter_method);
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            : #  define C(item) if (item != dp-&gt;item) \
<span class="lineNum">    1007 </span>            :       display_log(dp, APP_WARNING, &quot;IHDR &quot; #item &quot;(%lu) changed to %lu&quot;,\
<span class="lineNum">    1008 </span>            :          (unsigned long)dp-&gt;item, (unsigned long)item), e = #item
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :    /* The IHDR should be identical: */
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :    C(width);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :    C(height);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :    C(bit_depth);</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :    C(color_type);</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :    C(interlace_method);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :    C(compression_method);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :    C(filter_method);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :    /* 'e' remains set to the name of the last thing changed: */
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :    if (e)</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :       display_log(dp, APP_ERROR, &quot;IHDR changed (%s)&quot;, e);</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :    /* All the chunks from the original PNG should be preserved in the output PNG
<span class="lineNum">    1024 </span>            :     * because the PNG format has not been changed.
<span class="lineNum">    1025 </span>            :     */
<span class="lineNum">    1026 </span>            :    {
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :       unsigned long chunks =</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :          png_get_valid(dp-&gt;read_pp, dp-&gt;read_ip, 0xffffffff);</span>
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :       if (chunks != dp-&gt;chunks)</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :          display_log(dp, APP_FAIL, &quot;PNG chunks changed from 0x%lx to 0x%lx&quot;,</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :             (unsigned long)dp-&gt;chunks, chunks);</span>
<span class="lineNum">    1033 </span>            :    }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :    /* rowbytes should be the same */
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :    rowbytes = png_get_rowbytes(dp-&gt;read_pp, dp-&gt;read_ip);</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :    /* NOTE: on 64-bit systems this may trash the top bits of rowbytes,
<span class="lineNum">    1039 </span>            :     * which could lead to weird error messages.
<span class="lineNum">    1040 </span>            :     */
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :    if (rowbytes != dp-&gt;original_rowbytes)</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       display_log(dp, APP_ERROR, &quot;PNG rowbytes changed from %lu to %lu&quot;,</span>
<span class="lineNum">    1043 </span>            :          (unsigned long)dp-&gt;original_rowbytes, (unsigned long)rowbytes);
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :    /* The rows should be the same too, unless the applied transforms includes
<span class="lineNum">    1046 </span>            :     * the shift transform, in which case low bits may have been lost.
<span class="lineNum">    1047 </span>            :     */
<span class="lineNum">    1048 </span>            :    {
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :       png_bytepp rows = png_get_rows(dp-&gt;read_pp, dp-&gt;read_ip);</span>
<span class="lineNum">    1050 </span>            :       unsigned int mask;  /* mask (if not zero) for the final byte */
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :       if (bit_depth &lt; 8)</span>
<span class="lineNum">    1053 </span>            :       {
<span class="lineNum">    1054 </span>            :          /* Need the stray bits at the end, this depends only on the low bits
<span class="lineNum">    1055 </span>            :           * of the image width; overflow does not matter.  If the width is an
<span class="lineNum">    1056 </span>            :           * exact multiple of 8 bits this gives a mask of 0, not 0xff.
<span class="lineNum">    1057 </span>            :           */
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :          mask = 0xff &amp; (0xff00 &gt;&gt; ((bit_depth * width) &amp; 7));</span>
<span class="lineNum">    1059 </span>            :       }
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :       else
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :          mask = 0;</span>
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :       if (rows == NULL)</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :          display_log(dp, LIBPNG_BUG, &quot;png_get_rows returned NULL&quot;);</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :       if ((applied_transforms &amp; PNG_TRANSFORM_SHIFT) == 0 ||</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :          (dp-&gt;active_transforms &amp; PNG_TRANSFORM_SHIFT) == 0 ||</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :          color_type == PNG_COLOR_TYPE_PALETTE)</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    1071 </span>            :          unsigned long y;
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :          for (y=0; y&lt;height; ++y)</span>
<span class="lineNum">    1074 </span>            :          {
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :             png_bytep row = rows[y];</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :             png_bytep orig = dp-&gt;original_rows[y];</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :             if (memcmp(row, orig, rowbytes-(mask != 0)) != 0 || (mask != 0 &amp;&amp;</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :                ((row[rowbytes-1] &amp; mask) != (orig[rowbytes-1] &amp; mask))))</span>
<span class="lineNum">    1080 </span>            :             {
<span class="lineNum">    1081 </span>            :                size_t x;
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            :                /* Find the first error */
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                for (x=0; x&lt;rowbytes-1; ++x) if (row[x] != orig[x])</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :                display_log(dp, APP_FAIL,</span>
<span class="lineNum">    1088 </span>            :                   &quot;byte(%lu,%lu) changed 0x%.2x -&gt; 0x%.2x&quot;,
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :                   (unsigned long)x, (unsigned long)y, orig[x], row[x]);</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :                return 0; /* don't keep reporting failed rows on 'continue' */</span>
<span class="lineNum">    1091 </span>            :             }
<span class="lineNum">    1092 </span>            :          }
<span class="lineNum">    1093 </span>            :       }
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :       else
<span class="lineNum">    1096 </span>            : #     ifdef PNG_sBIT_SUPPORTED
<span class="lineNum">    1097 </span>            :       {
<span class="lineNum">    1098 </span>            :          unsigned long y;
<span class="lineNum">    1099 </span>            :          int bpp;   /* bits-per-pixel then bytes-per-pixel */
<span class="lineNum">    1100 </span>            :          /* components are up to 8 bytes in size */
<span class="lineNum">    1101 </span>            :          png_byte sig_bits[8];
<span class="lineNum">    1102 </span>            :          png_color_8p sBIT;
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :          if (png_get_sBIT(dp-&gt;read_pp, dp-&gt;read_ip, &amp;sBIT) != PNG_INFO_sBIT)</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :             display_log(dp, INTERNAL_ERROR,</span>
<span class="lineNum">    1106 </span>            :                &quot;active shift transform but no sBIT in file&quot;);
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :          switch (color_type)</span>
<span class="lineNum">    1109 </span>            :          {
<span class="lineNum">    1110 </span>            :             case PNG_COLOR_TYPE_GRAY:
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :                sig_bits[0] = sBIT-&gt;gray;</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                bpp = bit_depth;</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :             case PNG_COLOR_TYPE_GA:
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :                sig_bits[0] = sBIT-&gt;gray;</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :                sig_bits[1] = sBIT-&gt;alpha;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :                bpp = 2 * bit_depth;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            :             case PNG_COLOR_TYPE_RGB:
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :                sig_bits[0] = sBIT-&gt;red;</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                sig_bits[1] = sBIT-&gt;green;</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :                sig_bits[2] = sBIT-&gt;blue;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                bpp = 3 * bit_depth;</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :             case PNG_COLOR_TYPE_RGBA:
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :                sig_bits[0] = sBIT-&gt;red;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :                sig_bits[1] = sBIT-&gt;green;</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                sig_bits[2] = sBIT-&gt;blue;</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :                sig_bits[3] = sBIT-&gt;alpha;</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :                bpp = 4 * bit_depth;</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :             default:
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                display_log(dp, LIBPNG_ERROR, &quot;invalid colour type %d&quot;,</span>
<span class="lineNum">    1138 </span>            :                   color_type);
<span class="lineNum">    1139 </span>            :                /*NOTREACHED*/
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                bpp = 0;</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1142 </span>            :          }
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            :          {
<span class="lineNum">    1145 </span>            :             int b;
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :             for (b=0; 8*b&lt;bpp; ++b)</span>
<span class="lineNum">    1148 </span>            :             {
<span class="lineNum">    1149 </span>            :                /* libpng should catch this; if not there is a security issue
<span class="lineNum">    1150 </span>            :                 * because an app (like this one) may overflow an array. In fact
<span class="lineNum">    1151 </span>            :                 * libpng doesn't catch this at present.
<span class="lineNum">    1152 </span>            :                 */
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                if (sig_bits[b] == 0 || sig_bits[b] &gt; bit_depth/*!palette*/)</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                   display_log(dp, LIBPNG_BUG,</span>
<span class="lineNum">    1155 </span>            :                      &quot;invalid sBIT[%u]  value %d returned for PNG bit depth %d&quot;,
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                      b, sig_bits[b], bit_depth);</span>
<span class="lineNum">    1157 </span>            :             }
<span class="lineNum">    1158 </span>            :          }
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :          if (bpp &lt; 8 &amp;&amp; bpp != bit_depth)</span>
<span class="lineNum">    1161 </span>            :          {
<span class="lineNum">    1162 </span>            :             /* sanity check; this is a grayscale PNG; something is wrong in the
<span class="lineNum">    1163 </span>            :              * code above.
<span class="lineNum">    1164 </span>            :              */
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :             display_log(dp, INTERNAL_ERROR, &quot;invalid bpp %u for bit_depth %u&quot;,</span>
<span class="lineNum">    1166 </span>            :                bpp, bit_depth);
<span class="lineNum">    1167 </span>            :          }
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :          switch (bit_depth)</span>
<span class="lineNum">    1170 </span>            :          {
<span class="lineNum">    1171 </span>            :             int b;
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :             case 16: /* Two bytes per component, big-endian */
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                for (b = (bpp &gt;&gt; 4); b &gt; 0; --b)</span>
<span class="lineNum">    1175 </span>            :                {
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :                   unsigned int sig = (unsigned int)(0xffff0000 &gt;&gt; sig_bits[b]);</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :                   sig_bits[2*b+1] = (png_byte)sig;</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :                   sig_bits[2*b+0] = (png_byte)(sig &gt;&gt; 8); /* big-endian */</span>
<span class="lineNum">    1180 </span>            :                }
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            :             case 8: /* One byte per component */
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :                for (b=0; b*8 &lt; bpp; ++b)</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :                   sig_bits[b] = (png_byte)(0xff00 &gt;&gt; sig_bits[b]);</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span>            :             case 1: /* allowed, but dumb */
<span class="lineNum">    1189 </span>            :                /* Value is 1 */
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :                sig_bits[0] = 0xff;</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :             case 2: /* Replicate 4 times */
<span class="lineNum">    1194 </span>            :                /* Value is 1 or 2 */
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                b = 0x3 &amp; ((0x3&lt;&lt;2) &gt;&gt; sig_bits[0]);</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :                b |= b &lt;&lt; 2;</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :                b |= b &lt;&lt; 4;</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                sig_bits[0] = (png_byte)b;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span>            :             case 4: /* Relicate twice */
<span class="lineNum">    1202 </span>            :                /* Value is 1, 2, 3 or 4 */
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                b = 0xf &amp; ((0xf &lt;&lt; 4) &gt;&gt; sig_bits[0]);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                b |= b &lt;&lt; 4;</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                sig_bits[0] = (png_byte)b;</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :             default:
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :                display_log(dp, LIBPNG_BUG, &quot;invalid bit depth %d&quot;, bit_depth);</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :                break;</span>
<span class="lineNum">    1211 </span>            :          }
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span>            :          /* Convert bpp to bytes; this gives '1' for low-bit depth grayscale,
<span class="lineNum">    1214 </span>            :           * where there are multiple pixels per byte.
<span class="lineNum">    1215 </span>            :           */
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :          bpp = (bpp+7) &gt;&gt; 3;</span>
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :          /* The mask can be combined with sig_bits[0] */
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :          if (mask != 0)</span>
<span class="lineNum">    1220 </span>            :          {
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :             mask &amp;= sig_bits[0];</span>
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :             if (bpp != 1 || mask == 0)</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :                display_log(dp, INTERNAL_ERROR, &quot;mask calculation error %u, %u&quot;,</span>
<span class="lineNum">    1225 </span>            :                   bpp, mask);
<span class="lineNum">    1226 </span>            :          }
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :          for (y=0; y&lt;height; ++y)</span>
<span class="lineNum">    1229 </span>            :          {
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :             png_bytep row = rows[y];</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :             png_bytep orig = dp-&gt;original_rows[y];</span>
<span class="lineNum">    1232 </span>            :             unsigned long x;
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :             for (x=0; x&lt;(width-(mask!=0)); ++x)</span>
<span class="lineNum">    1235 </span>            :             {
<span class="lineNum">    1236 </span>            :                int b;
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                for (b=0; b&lt;bpp; ++b)</span>
<span class="lineNum">    1239 </span>            :                {
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                   if ((*row++ &amp; sig_bits[b]) != (*orig++ &amp; sig_bits[b]))</span>
<span class="lineNum">    1241 </span>            :                   {
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :                      display_log(dp, APP_FAIL,</span>
<span class="lineNum">    1243 </span>            :                         &quot;significant bits at (%lu[%u],%lu) changed %.2x-&gt;%.2x&quot;,
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :                         x, b, y, orig[-1], row[-1]);</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                      return 0;</span>
<span class="lineNum">    1246 </span>            :                   }
<span class="lineNum">    1247 </span>            :                }
<span class="lineNum">    1248 </span>            :             }
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :             if (mask != 0 &amp;&amp; (*row &amp; mask) != (*orig &amp; mask))</span>
<span class="lineNum">    1251 </span>            :             {
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :                display_log(dp, APP_FAIL,</span>
<span class="lineNum">    1253 </span>            :                   &quot;significant bits at (%lu[end],%lu) changed&quot;, x, y);
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :                return 0;</span>
<span class="lineNum">    1255 </span>            :             }
<span class="lineNum">    1256 </span>            :          } /* for y */
<span class="lineNum">    1257 </span>            :       }
<span class="lineNum">    1258 </span>            : #     else /* !sBIT */
<span class="lineNum">    1259 </span>            :          display_log(dp, INTERNAL_ERROR,
<span class="lineNum">    1260 </span>            :                &quot;active shift transform but no sBIT support&quot;);
<span class="lineNum">    1261 </span>            : #     endif /* !sBIT */
<span class="lineNum">    1262 </span>            :    }
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :    return 1; /* compare succeeded */</span>
<span class="lineNum">    1265 </span>            : }
<span class="lineNum">    1266 </span>            : 
<a name="1267"><span class="lineNum">    1267 </span>            : #ifdef PNG_WRITE_PNG_SUPPORTED</a>
<span class="lineNum">    1268 </span>            : static void
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 : buffer_write(struct display *dp, struct buffer *buffer, png_bytep data,</span>
<span class="lineNum">    1270 </span>            :    png_size_t size)
<span class="lineNum">    1271 </span>            :    /* Generic write function used both from the write callback provided to
<span class="lineNum">    1272 </span>            :     * libpng and from the generic read code.
<span class="lineNum">    1273 </span>            :     */
<span class="lineNum">    1274 </span>            : {
<span class="lineNum">    1275 </span>            :    /* Write the data into the buffer, adding buffers as required */
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :    struct buffer_list *last = buffer-&gt;last;</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :    size_t end_count = buffer-&gt;end_count;</span>
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :    while (size &gt; 0)</span>
<span class="lineNum">    1280 </span>            :    {
<span class="lineNum">    1281 </span>            :       size_t avail;
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :       if (end_count &gt;= sizeof last-&gt;buffer)</span>
<span class="lineNum">    1284 </span>            :       {
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :          if (last-&gt;next == NULL)</span>
<span class="lineNum">    1286 </span>            :          {
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :             last = buffer_extend(last);</span>
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :             if (last == NULL)</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                display_log(dp, APP_ERROR, &quot;out of memory saving file&quot;);</span>
<span class="lineNum">    1291 </span>            :          }
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            :          else
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :             last = last-&gt;next;</span>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :          buffer-&gt;last = last; /* avoid the need to rewrite every time */</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :          end_count = 0;</span>
<span class="lineNum">    1298 </span>            :       }
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :       avail = (sizeof last-&gt;buffer) - end_count;</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :       if (avail &gt; size)</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :          avail = size;</span>
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :       memcpy(last-&gt;buffer + end_count, data, avail);</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :       end_count += avail;</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :       size -= avail;</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :       data += avail;</span>
<span class="lineNum">    1308 </span>            :    }
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :    buffer-&gt;end_count = end_count;</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 : }</span>
<a name="1312"><span class="lineNum">    1312 </span>            : </a>
<span class="lineNum">    1313 </span>            : static void PNGCBAPI
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 : write_function(png_structp pp, png_bytep data, png_size_t size)</span>
<span class="lineNum">    1315 </span>            : {
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :    buffer_write(get_dp(pp), get_buffer(pp), data, size);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 : }</span>
<a name="1318"><span class="lineNum">    1318 </span>            : </a>
<span class="lineNum">    1319 </span>            : static void
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 : write_png(struct display *dp, png_infop ip, int transforms)</span>
<span class="lineNum">    1321 </span>            : {
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :    display_clean_write(dp); /* safety */</span>
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :    buffer_start_write(&amp;dp-&gt;written_file);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :    dp-&gt;operation = &quot;write&quot;;</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :    dp-&gt;transforms = transforms;</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :    dp-&gt;write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,</span>
<span class="lineNum">    1329 </span>            :       display_error, display_warning);
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :    if (dp-&gt;write_pp == NULL)</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :       display_log(dp, APP_ERROR, &quot;failed to create write png_struct&quot;);</span>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :    png_set_write_fn(dp-&gt;write_pp, &amp;dp-&gt;written_file, write_function,</span>
<span class="lineNum">    1335 </span>            :       NULL/*flush*/);
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            : #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
<span class="lineNum">    1338 </span>            :       /* Remove the user limits, if any */
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :       png_set_user_limits(dp-&gt;write_pp, 0x7fffffff, 0x7fffffff);</span>
<span class="lineNum">    1340 </span>            : #  endif
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            :    /* Certain transforms require the png_info to be zapped to allow the
<span class="lineNum">    1343 </span>            :     * transform to work correctly.
<span class="lineNum">    1344 </span>            :     */
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :    if (transforms &amp; (PNG_TRANSFORM_PACKING|</span>
<span class="lineNum">    1346 </span>            :                      PNG_TRANSFORM_STRIP_FILLER|
<span class="lineNum">    1347 </span>            :                      PNG_TRANSFORM_STRIP_FILLER_BEFORE))
<span class="lineNum">    1348 </span>            :    {
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :       int ct = dp-&gt;color_type;</span>
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :       if (transforms &amp; (PNG_TRANSFORM_STRIP_FILLER|</span>
<span class="lineNum">    1352 </span>            :                         PNG_TRANSFORM_STRIP_FILLER_BEFORE))
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :          ct &amp;= ~PNG_COLOR_MASK_ALPHA;</span>
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :       png_set_IHDR(dp-&gt;write_pp, ip, dp-&gt;width, dp-&gt;height, dp-&gt;bit_depth, ct,</span>
<span class="lineNum">    1356 </span>            :          dp-&gt;interlace_method, dp-&gt;compression_method, dp-&gt;filter_method);
<span class="lineNum">    1357 </span>            :    }
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :    png_write_png(dp-&gt;write_pp, ip, transforms, NULL/*params*/);</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :    /* Clean it on the way out - if control returns to the caller then the
<span class="lineNum">    1362 </span>            :     * written_file contains the required data.
<span class="lineNum">    1363 </span>            :     */
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :    display_clean_write(dp);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1366 </span>            : #endif /* WRITE_PNG */
<a name="1367"><span class="lineNum">    1367 </span>            : </a>
<span class="lineNum">    1368 </span>            : static int
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 : skip_transform(struct display *dp, int tr)</span>
<span class="lineNum">    1370 </span>            :    /* Helper to test for a bad combo and log it if it is skipped */
<span class="lineNum">    1371 </span>            : {
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :    if ((dp-&gt;options &amp; SKIP_BUGS) != 0 &amp;&amp; is_bad_combo(tr))</span>
<span class="lineNum">    1373 </span>            :    {
<span class="lineNum">    1374 </span>            :       /* Log this to stdout if logging is on, otherwise just do an information
<span class="lineNum">    1375 </span>            :        * display_log.
<span class="lineNum">    1376 </span>            :        */
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :       if ((dp-&gt;options &amp; LOG_SKIPPED) != 0)</span>
<span class="lineNum">    1378 </span>            :       {
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :          printf(&quot;SKIP: %s transforms &quot;, dp-&gt;filename);</span>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :          while (tr != 0)</span>
<span class="lineNum">    1382 </span>            :          {
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :             int next = first_transform(tr);</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :             tr &amp;= ~next;</span>
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :             printf(&quot;%s&quot;, transform_name(next));</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :             if (tr != 0)</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :                putchar('+');</span>
<span class="lineNum">    1389 </span>            :          }
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :          putchar('\n');</span>
<span class="lineNum">    1392 </span>            :       }
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            :       else
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :          display_log(dp, INFORMATION, &quot;%s: skipped known bad combo 0x%x&quot;,</span>
<span class="lineNum">    1396 </span>            :             dp-&gt;filename, tr);
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :       return 1; /* skip */</span>
<span class="lineNum">    1399 </span>            :    }
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :    return 0; /* don't skip */</span>
<span class="lineNum">    1402 </span>            : }
<a name="1403"><span class="lineNum">    1403 </span>            : </a>
<span class="lineNum">    1404 </span>            : static void
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 : test_one_file(struct display *dp, const char *filename)</span>
<span class="lineNum">    1406 </span>            : {
<span class="lineNum">    1407 </span>            :    /* First cache the file and update the display original file
<span class="lineNum">    1408 </span>            :     * information for the new file.
<span class="lineNum">    1409 </span>            :     */
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :    dp-&gt;operation = &quot;cache file&quot;;</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :    dp-&gt;transforms = 0;</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :    display_cache_file(dp, filename);</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :    update_display(dp);</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            :    /* First test: if there are options that should be ignored for this file
<span class="lineNum">    1416 </span>            :     * verify that they really are ignored.
<span class="lineNum">    1417 </span>            :     */
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :    if (dp-&gt;ignored_transforms != 0)</span>
<span class="lineNum">    1419 </span>            :    {
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :       read_png(dp, &amp;dp-&gt;original_file, &quot;ignored transforms&quot;,</span>
<span class="lineNum">    1421 </span>            :          dp-&gt;ignored_transforms);
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            :       /* The result should be identical to the original_rows */
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :       if (!compare_read(dp, 0/*transforms applied*/))</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :          return; /* no point testing more */</span>
<span class="lineNum">    1426 </span>            :    }
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            : #ifdef PNG_WRITE_PNG_SUPPORTED
<span class="lineNum">    1429 </span>            :    /* Second test: write the original PNG data out to a new file (to test the
<span class="lineNum">    1430 </span>            :     * write side) then read the result back in and make sure that it hasn't
<span class="lineNum">    1431 </span>            :     * changed.
<span class="lineNum">    1432 </span>            :     */
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :    dp-&gt;operation = &quot;write&quot;;</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :    write_png(dp, dp-&gt;original_ip, 0/*transforms*/);</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :    read_png(dp, &amp;dp-&gt;written_file, NULL, 0/*transforms*/);</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :    if (!compare_read(dp, 0/*transforms applied*/))</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1438 </span>            : #endif
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span>            :    /* Third test: the active options.  Test each in turn, or, with the
<span class="lineNum">    1441 </span>            :     * EXHAUSTIVE option, test all possible combinations.
<span class="lineNum">    1442 </span>            :     */
<span class="lineNum">    1443 </span>            :    {
<span class="lineNum">    1444 </span>            :       /* Use unsigned int here because the code below to increment through all
<span class="lineNum">    1445 </span>            :        * the possibilities exhaustively has to use a compare and that must be
<span class="lineNum">    1446 </span>            :        * unsigned, because some transforms are negative on a 16-bit system.
<span class="lineNum">    1447 </span>            :        */
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :       unsigned int active = dp-&gt;active_transforms;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :       const int exhaustive = (dp-&gt;options &amp; EXHAUSTIVE) != 0;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :       unsigned int current = first_transform(active);</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :       unsigned int bad_transforms = 0;</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :       unsigned int bad_combo = ~0U;    /* bitwise AND of failing transforms */</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :       unsigned int bad_combo_list = 0; /* bitwise OR of failures */</span>
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            :       for (;;)
<span class="lineNum">    1456 </span>            :       {
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :          read_png(dp, &amp;dp-&gt;original_file, &quot;active transforms&quot;, current);</span>
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span>            :          /* If this involved any irreversible transformations then if we write
<span class="lineNum">    1460 </span>            :           * it out with just the reversible transformations and read it in again
<span class="lineNum">    1461 </span>            :           * with the same transforms we should get the same thing.  At present
<span class="lineNum">    1462 </span>            :           * this isn't done - it just seems like a waste of time and it would
<span class="lineNum">    1463 </span>            :           * require two sets of read png_struct/png_info.
<span class="lineNum">    1464 </span>            :           *
<span class="lineNum">    1465 </span>            :           * If there were no irreversible transformations then if we write it
<span class="lineNum">    1466 </span>            :           * out and read it back in again (without the reversible transforms)
<span class="lineNum">    1467 </span>            :           * we should get back to the place where we started.
<span class="lineNum">    1468 </span>            :           */
<span class="lineNum">    1469 </span>            : #ifdef PNG_WRITE_PNG_SUPPORTED
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :          if ((current &amp; write_transforms) == current)</span>
<span class="lineNum">    1471 </span>            :          {
<span class="lineNum">    1472 </span>            :             /* All transforms reversible: write the PNG with the transformations
<span class="lineNum">    1473 </span>            :              * reversed, then read it back in with no transformations.  The
<span class="lineNum">    1474 </span>            :              * result should be the same as the original apart from the loss of
<span class="lineNum">    1475 </span>            :              * low order bits because of the SHIFT/sBIT transform.
<span class="lineNum">    1476 </span>            :              */
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :             dp-&gt;operation = &quot;reversible transforms&quot;;</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :             write_png(dp, dp-&gt;read_ip, current);</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :             /* And if this is read back in, because all the transformations were
<span class="lineNum">    1481 </span>            :              * reversible, the result should be the same.
<span class="lineNum">    1482 </span>            :              */
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :             read_png(dp, &amp;dp-&gt;written_file, NULL, 0);</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :             if (!compare_read(dp, current/*for the SHIFT/sBIT transform*/))</span>
<span class="lineNum">    1485 </span>            :             {
<span class="lineNum">    1486 </span>            :                /* This set of transforms failed.  If a single bit is set - if
<span class="lineNum">    1487 </span>            :                 * there is just one transform - don't include this in further
<span class="lineNum">    1488 </span>            :                 * 'exhaustive' tests.  Notice that each transform is tested on
<span class="lineNum">    1489 </span>            :                 * its own before testing combos in the exhaustive case.
<span class="lineNum">    1490 </span>            :                 */
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :                if (is_combo(current))</span>
<span class="lineNum">    1492 </span>            :                {
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :                   bad_combo &amp;= current;</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :                   bad_combo_list |= current;</span>
<span class="lineNum">    1495 </span>            :                }
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            :                else
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :                   bad_transforms |= current;</span>
<span class="lineNum">    1499 </span>            :             }
<span class="lineNum">    1500 </span>            :          }
<span class="lineNum">    1501 </span>            : #endif
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            :          /* Now move to the next transform */
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :          if (exhaustive) /* all combinations */</span>
<span class="lineNum">    1505 </span>            :          {
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :             unsigned int next = current;</span>
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            :             do
<span class="lineNum">    1509 </span>            :             {
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :                if (next == read_transforms) /* Everything tested */</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :                   goto combo;</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :                ++next;</span>
<span class="lineNum">    1514 </span>            :             }  /* skip known bad combos if the relevant option is set; skip
<span class="lineNum">    1515 </span>            :                 * combos involving known bad single transforms in all cases.
<span class="lineNum">    1516 </span>            :                 */
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :             while (  (next &amp; read_transforms) &lt;= current</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :                   || (next &amp; active) == 0 /* skip cases that do nothing */</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :                   || (next &amp; bad_transforms) != 0</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :                   || skip_transform(dp, next));</span>
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :             assert((next &amp; read_transforms) == next);</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :             current = next;</span>
<span class="lineNum">    1524 </span>            :          }
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :          else /* one at a time */
<span class="lineNum">    1527 </span>            :          {
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :             active &amp;= ~current;</span>
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :             if (active == 0)</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :                goto combo;</span>
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :             current = first_transform(active);</span>
<span class="lineNum">    1534 </span>            :          }
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span>            : combo:
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :       if (dp-&gt;options &amp; FIND_BAD_COMBOS)</span>
<span class="lineNum">    1539 </span>            :       {
<span class="lineNum">    1540 </span>            :          /* bad_combos identifies the combos that occur in all failing cases;
<span class="lineNum">    1541 </span>            :           * bad_combo_list identifies transforms that do not prevent the
<span class="lineNum">    1542 </span>            :           * failure.
<span class="lineNum">    1543 </span>            :           */
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :          if (bad_combo != ~0U)</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :             printf(&quot;%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x\n&quot;,</span>
<span class="lineNum">    1546 </span>            :                dp-&gt;filename, active, bad_combo, bad_combo_list,
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :                rw_transforms &amp; ~bad_combo_list);</span>
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span>            :          else
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :             printf(&quot;%s: no %sbad combos found\n&quot;, dp-&gt;filename,</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :                (dp-&gt;options &amp; SKIP_BUGS) ? &quot;additional &quot; : &quot;&quot;);</span>
<span class="lineNum">    1552 </span>            :       }
<span class="lineNum">    1553 </span>            :    }
<span class="lineNum">    1554 </span>            : }
<a name="1555"><span class="lineNum">    1555 </span>            : </a>
<span class="lineNum">    1556 </span>            : static int
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 : do_test(struct display *dp, const char *file)</span>
<span class="lineNum">    1558 </span>            :    /* Exists solely to isolate the setjmp clobbers */
<span class="lineNum">    1559 </span>            : {
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :    int ret = setjmp(dp-&gt;error_return);</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :    if (ret == 0)</span>
<span class="lineNum">    1563 </span>            :    {
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :       test_one_file(dp, file);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    1566 </span>            :    }
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :    else if (ret &lt; ERRORS) /* shouldn't longjmp on warnings */</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :       display_log(dp, INTERNAL_ERROR, &quot;unexpected return code %d&quot;, ret);</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :    return ret;</span>
<span class="lineNum">    1572 </span>            : }
<a name="1573"><span class="lineNum">    1573 </span>            : </a>
<span class="lineNum">    1574 </span>            : int
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 : main(const int argc, const char * const * const argv)</span>
<span class="lineNum">    1576 </span>            : {
<span class="lineNum">    1577 </span>            :    /* For each file on the command line test it with a range of transforms */
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :    int option_end, ilog = 0;</span>
<span class="lineNum">    1579 </span>            :    struct display d;
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :    validate_T();</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :    display_init(&amp;d);</span>
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :    for (option_end=1; option_end&lt;argc; ++option_end)</span>
<span class="lineNum">    1585 </span>            :    {
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :       const char *name = argv[option_end];</span>
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :       if (strcmp(name, &quot;--verbose&quot;) == 0)</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :          d.options = (d.options &amp; ~LEVEL_MASK) | VERBOSE;</span>
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--warnings&quot;) == 0)</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :          d.options = (d.options &amp; ~LEVEL_MASK) | WARNINGS;</span>
<span class="lineNum">    1593 </span>            : 
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--errors&quot;) == 0)</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :          d.options = (d.options &amp; ~LEVEL_MASK) | ERRORS;</span>
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--quiet&quot;) == 0)</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :          d.options = (d.options &amp; ~LEVEL_MASK) | QUIET;</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--exhaustive&quot;) == 0)</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :          d.options |= EXHAUSTIVE;</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--fast&quot;) == 0)</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :          d.options &amp;= ~EXHAUSTIVE;</span>
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--strict&quot;) == 0)</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :          d.options |= STRICT;</span>
<span class="lineNum">    1608 </span>            : 
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--relaxed&quot;) == 0)</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :          d.options &amp;= ~STRICT;</span>
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--log&quot;) == 0)</span>
<span class="lineNum">    1613 </span>            :       {
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :          ilog = option_end; /* prevent display */</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :          d.options |= LOG;</span>
<span class="lineNum">    1616 </span>            :       }
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--nolog&quot;) == 0)</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :          d.options &amp;= ~LOG;</span>
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--continue&quot;) == 0)</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :          d.options |= CONTINUE;</span>
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--stop&quot;) == 0)</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :          d.options &amp;= ~CONTINUE;</span>
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--skip-bugs&quot;) == 0)</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :          d.options |= SKIP_BUGS;</span>
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--test-all&quot;) == 0)</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :          d.options &amp;= ~SKIP_BUGS;</span>
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--log-skipped&quot;) == 0)</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :          d.options |= LOG_SKIPPED;</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--nolog-skipped&quot;) == 0)</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :          d.options &amp;= ~LOG_SKIPPED;</span>
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--find-bad-combos&quot;) == 0)</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :          d.options |= FIND_BAD_COMBOS;</span>
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--nofind-bad-combos&quot;) == 0)</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :          d.options &amp;= ~FIND_BAD_COMBOS;</span>
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--list-combos&quot;) == 0)</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :          d.options |= LIST_COMBOS;</span>
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :       else if (strcmp(name, &quot;--nolist-combos&quot;) == 0)</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :          d.options &amp;= ~LIST_COMBOS;</span>
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :       else if (name[0] == '-' &amp;&amp; name[1] == '-')</span>
<span class="lineNum">    1652 </span>            :       {
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :          fprintf(stderr, &quot;pngimage: %s: unknown option\n&quot;, name);</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :          return 99;</span>
<span class="lineNum">    1655 </span>            :       }
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            :       else
<span class="lineNum">    1658 </span>            :          break; /* Not an option */
<span class="lineNum">    1659 </span>            :    }
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            :    {
<span class="lineNum">    1662 </span>            :       int i;
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :       int errors = 0;</span>
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :       for (i=option_end; i&lt;argc; ++i)</span>
<span class="lineNum">    1666 </span>            :       {
<span class="lineNum">    1667 </span>            :          {
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :             int ret = do_test(&amp;d, argv[i]);</span>
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :             if (ret &gt; QUIET) /* abort on user or internal error */</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :                return 99;</span>
<span class="lineNum">    1672 </span>            :          }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            :          /* Here on any return, including failures, except user/internal issues
<span class="lineNum">    1675 </span>            :           */
<span class="lineNum">    1676 </span>            :          {
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :             const int pass = (d.options &amp; STRICT) ?</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :                RESULT_STRICT(d.results) : RESULT_RELAXED(d.results);</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :             if (!pass)</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :                ++errors;</span>
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :             if (d.options &amp; LOG)</span>
<span class="lineNum">    1684 </span>            :             {
<span class="lineNum">    1685 </span>            :                int j;
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :                printf(&quot;%s: pngimage &quot;, pass ? &quot;PASS&quot; : &quot;FAIL&quot;);</span>
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :                for (j=1; j&lt;option_end; ++j) if (j != ilog)</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                   printf(&quot;%s &quot;, argv[j]);</span>
<span class="lineNum">    1691 </span>            : 
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :                printf(&quot;%s\n&quot;, d.filename);</span>
<span class="lineNum">    1693 </span>            :             }
<span class="lineNum">    1694 </span>            :          }
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :          display_clean(&amp;d);</span>
<span class="lineNum">    1697 </span>            :       }
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            :       /* Release allocated memory */
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :       display_destroy(&amp;d);</span>
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :       return errors != 0;</span>
<span class="lineNum">    1703 </span>            :    }
<span class="lineNum">    1704 </span>            : }
<span class="lineNum">    1705 </span>            : #else /* !READ_PNG */
<span class="lineNum">    1706 </span>            : int
<span class="lineNum">    1707 </span>            : main(void)
<span class="lineNum">    1708 </span>            : {
<span class="lineNum">    1709 </span>            :    fprintf(stderr, &quot;pngimage: no support for png_read/write_image\n&quot;);
<span class="lineNum">    1710 </span>            :    return SKIP;
<span class="lineNum">    1711 </span>            : }
<span class="lineNum">    1712 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
